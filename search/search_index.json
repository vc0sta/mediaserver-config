{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is the knowledgebase to configure your own mediaserver. The current scripts and service are currently running in a Raspberry Pi 4, but everything should work on any other hardware with container capabilities. Overview The Mediaserver project started with the objective of creating a self-hosted media solution with automated downloads for movies and series via torrent. But as it evolved, the scope became bigger and bigger, and now it is running all of my self hosted services. Table of contents Overview Table of contents Hardware Specifications Integration Services Volumes Hardware Specifications The server itself has nothing special regarding hardware: RaspberryPi 4 7TB external Harddrive mounted in '/mnt/storage' Integration Services This is diagram shows how the services interact with themselves since a new media is requested until it become available to be reproduced : User create a new request via requests.DOMAIN ; Ombi is integrated with Jellyfin , so there will be no duplicates; Depending on which kind of media is requested, it will notify Sonarr or Radarr ; Sonarr/Radarr will fetch download options from the Jackett If there is a download to be made, Sonar/Radarr add it to Deluge and tracks its progress; As soon as the download is complete, Bazarr is notified and start looking for subtitles; Jellyfin is then notified and scans the media folder; The User is now able to reproduce the requested media; Volumes Apart from the diagram above, we have some interaction at a volume level, this is why some services have some volume mapping in common. The diagram below illustrates that: A new file is donwloaded into Downloads folder; Sonarr/Radarr creates a hard link of the media files to Movies or Series ; (*) Bazarr gets notified a new file arrived, and download subtitles into this folders; Jellyfin then serves the downloaded media from the latter; The hard link strategy, allows us to keep the same file in 2+ different folders. This way we can keep the folder structure to Deluge be able to seed those files, and we can organize our library to Jellyfin without duplicating any files. At downloads folder you have something like this: downloads \u251c\u2500\u2500 Studio.666.2022.PROPER.1080p.WEBRip.x264-RARBG : : \u251c\u2500\u2500 Westworld.S04E06.720p.WEB.h264-KOGi[TGx] \u2514\u2500\u2500 Westworld.S04E07.720p.WEB.H264-CAKES[TGx] And at the media folder you have: movies : \u251c\u2500\u2500 Studio 666 (2022) \u2502 \u251c\u2500\u2500 Studio 666 (2022).en.srt \u2502 \u251c\u2500\u2500 Studio 666 (2022).mp4 \u2502 \u2514\u2500\u2500 Studio 666 (2022).pt-BR.srt : series : \u251c\u2500\u2500 Westworld (2016) : : \u2502 \u2514\u2500\u2500 Season 4 \u2502 \u251c\u2500\u2500 metadata : : \u2502 \u251c\u2500\u2500 Westworld (2016) S04E06 - Fidelity.mkv \u2502 \u251c\u2500\u2500 Westworld (2016) S04E06 - Fidelity.pt-BR.srt \u2502 \u251c\u2500\u2500 Westworld (2016) S04E07 - Metanoia.mkv \u2502 \u2514\u2500\u2500 Westworld (2016) S04E07 - Metanoia.pt-BR.srt : Note: Once the torrent stops seeding the file will be copied, so always check your available storage and clean it up periodically.","title":"Home"},{"location":"#overview","text":"The Mediaserver project started with the objective of creating a self-hosted media solution with automated downloads for movies and series via torrent. But as it evolved, the scope became bigger and bigger, and now it is running all of my self hosted services.","title":"Overview"},{"location":"#table-of-contents","text":"Overview Table of contents Hardware Specifications Integration Services Volumes","title":"Table of contents"},{"location":"#hardware-specifications","text":"The server itself has nothing special regarding hardware: RaspberryPi 4 7TB external Harddrive mounted in '/mnt/storage'","title":"Hardware Specifications"},{"location":"#integration","text":"","title":"Integration"},{"location":"#services","text":"This is diagram shows how the services interact with themselves since a new media is requested until it become available to be reproduced : User create a new request via requests.DOMAIN ; Ombi is integrated with Jellyfin , so there will be no duplicates; Depending on which kind of media is requested, it will notify Sonarr or Radarr ; Sonarr/Radarr will fetch download options from the Jackett If there is a download to be made, Sonar/Radarr add it to Deluge and tracks its progress; As soon as the download is complete, Bazarr is notified and start looking for subtitles; Jellyfin is then notified and scans the media folder; The User is now able to reproduce the requested media;","title":"Services"},{"location":"#volumes","text":"Apart from the diagram above, we have some interaction at a volume level, this is why some services have some volume mapping in common. The diagram below illustrates that: A new file is donwloaded into Downloads folder; Sonarr/Radarr creates a hard link of the media files to Movies or Series ; (*) Bazarr gets notified a new file arrived, and download subtitles into this folders; Jellyfin then serves the downloaded media from the latter; The hard link strategy, allows us to keep the same file in 2+ different folders. This way we can keep the folder structure to Deluge be able to seed those files, and we can organize our library to Jellyfin without duplicating any files. At downloads folder you have something like this: downloads \u251c\u2500\u2500 Studio.666.2022.PROPER.1080p.WEBRip.x264-RARBG : : \u251c\u2500\u2500 Westworld.S04E06.720p.WEB.h264-KOGi[TGx] \u2514\u2500\u2500 Westworld.S04E07.720p.WEB.H264-CAKES[TGx] And at the media folder you have: movies : \u251c\u2500\u2500 Studio 666 (2022) \u2502 \u251c\u2500\u2500 Studio 666 (2022).en.srt \u2502 \u251c\u2500\u2500 Studio 666 (2022).mp4 \u2502 \u2514\u2500\u2500 Studio 666 (2022).pt-BR.srt : series : \u251c\u2500\u2500 Westworld (2016) : : \u2502 \u2514\u2500\u2500 Season 4 \u2502 \u251c\u2500\u2500 metadata : : \u2502 \u251c\u2500\u2500 Westworld (2016) S04E06 - Fidelity.mkv \u2502 \u251c\u2500\u2500 Westworld (2016) S04E06 - Fidelity.pt-BR.srt \u2502 \u251c\u2500\u2500 Westworld (2016) S04E07 - Metanoia.mkv \u2502 \u2514\u2500\u2500 Westworld (2016) S04E07 - Metanoia.pt-BR.srt : Note: Once the torrent stops seeding the file will be copied, so always check your available storage and clean it up periodically.","title":"Volumes"},{"location":"configuration/HTTPS-configuration/","text":"To renew my TLS certificates, I'm using the scripts from Certbot-Godaddy . It's usage is very simple: Create a new API Key , and set your credentials at api-settings.sh : ############################################################ # Domain settings DOMAIN=example.com EMAIL=letsencrypt@${DOMAIN} ############################################################ ############################################################ # GoDaddy API Credentials GODADDY_API_KEY=\"\" GODADDY_API_SECRET=\"\" GODADDY_URL=\"https://api.godaddy.com/\" ############################################################ Then run certbot-godaddy-request.sh : # Give execute permissions to the script chmod +x certbot-godaddy-request.sh # Run it ./certbot-godaddy-request.sh Your new certificate should be stored in /etc/letsencrypt/live/ [DOMAIN] / To use this certificate, see NGIX Configuration .","title":"HTTPS configuration"},{"location":"configuration/dhcp-socket-overflow/","text":"Every new container running will create a new Virtual Network Interface and each interface will request DHCPD service. As we are running a lot of containers and they don't need to get anything from DHCP, we can simply exclude the virtual container interfaces from dhcpcd. sudo vi /etc/dhcpcd.conf # Insert the following line at the end: denyinterfaces veth*","title":"Dhcp socket overflow"},{"location":"configuration/dns-update/","text":"My internet has no fixed IP address, so I had to update it manually everytime the connection is interrupted and a new IP is assigned. To solve it, I created a little shellscript to check the current IP configuration at GoDaddy (my DNS provider) and the current WAN IP address of my network. If those values don't match, then I update the DNS with my new IP. Here is the script: #!/usr/bin/bash # daddy-autoupdate.sh DOMAIN=vcosta.dev SUBDOMAINS=(play requests vpn) DESIRED_IP=$(curl ifconfig.me -s) for SUBDOMAIN in \"${SUBDOMAINS[@]}\" do CURRENT_IP=$(/usr/local/bin/daddy show -d ${DOMAIN} -n ${SUBDOMAIN} -t A | grep ${SUBDOMAIN} | cut -d\"|\" -f 3) if [ ! $CURRENT_IP = $DESIRED_IP ]; then /usr/local/bin/daddy update --domain ${DOMAIN} -t A -n ${SUBDOMAIN} -v ${DESIRED_IP}; echo $(date +\"%Y-%m-%d %H:%M\") Updating $SUBDOMAIN.$DOMAIN from $CURRENT_IP to $DESIRED_IP fi done I'm using daddy to manage my DNS records, it requires to setup a key/secret at \\${HOME}/.daddy.yaml . Create a new API Key , then add it's values like: --- key: 1234567689 secret: 1234567689 Cronjob Also, I've set up this script to run each 30min using crontab: crontab -e # Then add this line at the end of the file: */30 * * * * /home/pi/daddy-autoupdate.sh","title":"Dns update"},{"location":"configuration/dns-update/#cronjob","text":"Also, I've set up this script to run each 30min using crontab: crontab -e # Then add this line at the end of the file: */30 * * * * /home/pi/daddy-autoupdate.sh","title":"Cronjob"},{"location":"configuration/mounting-storage/","text":"You can mount your storage device at a specific folder location. It is conventional to do this within the /mnt folder, for example /mnt/storage . Note that the folder must be empty. Plug the storage device into a USB port on the Raspberry Pi. List all the disk partitions on the Raspberry Pi using the following command: sudo lsblk -o UUID,NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL,MODEL You should get an output like this: UUID NAME FSTYPE SIZE MOUNTPOINT LABEL MODEL loop0 squashfs 84.4M /snap/core/11321 sda 5.5T Expansion_Desk 67E3-17ED \u251c\u2500sda1 vfat 200M EFI 6088-A250 \u2514\u2500sda2 exfat 5.5T storage mmcblk0 29.7G 7581-8A48 \u251c\u2500mmcblk0p1 vfat 256M /boot boot fa37d505-e741-4d35-bcec-4580aef395e1 \u2514\u2500mmcblk0p2 ext4 29.5G / rootfs The Raspberry Pi uses mount points / and /boot . Your storage device will show up in this list, along with any other connected storage. Use the SIZE, LABEL, and MODEL columns to identify the name of the disk partition that points to your storage device. For example, sda1. The FSTYPE column contains the filesystem type. If your storage device uses an exFAT file system, install the exFAT driver: sudo apt update sudo apt install exfat-fuse If your storage device uses an NTFS file system, you will have read-only access to it. If you want to write to the device, you can install the ntfs-3g driver: sudo apt update sudo apt install ntfs-3g Run the following command to get the location of the disk partition: sudo blkid For example, /dev/sda1 . Create a target folder to be the mount point of the storage device. The mount point name used in this case is storage . You can specify a name of your choice: sudo mkdir /mnt/storage Mount the storage device at the mount point you created: sudo mount /dev/sda1 /mnt/storage Verify that the storage device is mounted successfully by listing the contents: ls /mnt/storage Setting up Automatic Mounting You can modify the fstab file to define the location where the storage device will be automatically mounted when the Raspberry Pi starts up. In the fstab file, the disk partition is identified by the universally unique identifier (UUID). Get the UUID of the disk partition: sudo blkid Find the disk partition from the list and note the UUID. For example, 5C24-1453. Open the fstab file using a command line editor such as nano: sudo nano /etc/fstab Add the following line in the fstab file: UUID=6088-A250 /mnt/storage fstype users,defaults,uid=1000,gid=1000,umask=0022,auto,rw,nofail,umask=000,x-systemd.device-timeout=30 0 0 Replace fstype with the type of your file system, for example: exfat. If the filesystem type is FAT or NTFS, add ,umask=000 immediately after nofail - this will allow all users full read/write access to every file on the storage device. This page was taken from the Official Documentation , please refer to it for more information.","title":"Mounting storage"},{"location":"configuration/mounting-storage/#setting-up-automatic-mounting","text":"You can modify the fstab file to define the location where the storage device will be automatically mounted when the Raspberry Pi starts up. In the fstab file, the disk partition is identified by the universally unique identifier (UUID). Get the UUID of the disk partition: sudo blkid Find the disk partition from the list and note the UUID. For example, 5C24-1453. Open the fstab file using a command line editor such as nano: sudo nano /etc/fstab Add the following line in the fstab file: UUID=6088-A250 /mnt/storage fstype users,defaults,uid=1000,gid=1000,umask=0022,auto,rw,nofail,umask=000,x-systemd.device-timeout=30 0 0 Replace fstype with the type of your file system, for example: exfat. If the filesystem type is FAT or NTFS, add ,umask=000 immediately after nofail - this will allow all users full read/write access to every file on the storage device. This page was taken from the Official Documentation , please refer to it for more information.","title":"Setting up Automatic Mounting"},{"location":"configuration/ssh-config/","text":"To configure SSH on your Respberry Pi, youo will need to enable sshd service in it: Then add your public keys to ~/.ssh/authorized_keys : touch ~/.ssh/authorized_keys curl https://github.com/your-username.keys >> ~/.ssh/authorized_keys Note: If you don't have SSH keys configured yet, you can follow GitHub documentation here and here . [Optional] Create an entry in ~/.ssh/config in your machine: Host raspi HostName 192.168.77.104 User pi IdentityFile ~/.ssh/id_rsa With everything in place, you can SSH into RaspberryPi by using: ssh raspi","title":"Ssh config"},{"location":"services/Media%20Management/bazarr/","text":"Bazarr is a companion application to Sonarr and Radarr. It can manage and download subtitles based on your requirements. You define your preferences by TV show or movie and Bazarr takes care of everything for you. Table of contents Folder Structure Docker-compose NGINX Related Tutorials Folder Structure bazarr \u251c\u2500\u2500 config # Service data \u251c\u2500\u2500 docker-compose.yml # Service configuration \u2514\u2500\u2500 update_libseccomp_rpi4.sh # Script to install libseccomp on Raspberry Pi 4 Note: I do not remember why I needed to install libseccomp, but I kept the commands I've used in update_libseccomp_rpi4.sh file. Docker-compose version: \"2.1\" services: bazarr: image: ghcr.io/linuxserver/bazarr container_name: bazarr environment: - PUID=1000 - PGID=1000 - TZ=${TZ} volumes: - ./config:/config - ${STORAGE_PATH}/Movies:/movies - ${STORAGE_PATH}/Series:/tv ports: - 6767:6767 restart: unless-stopped NGINX HTTP # Bazarr server { listen 80; server_name subtitles.EXAMPLE.COM; location / { proxy_pass http://bazarr:6767; } } HTTPS # Bazarr server { listen 80; server_name subtitles.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name subtitles.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://bazarr:6767; allow 192.168.77.0/24; deny all; } } Related Tutorials TODO: Configure Subtitle Profiles","title":"Bazarr"},{"location":"services/Media%20Management/bazarr/#table-of-contents","text":"Folder Structure Docker-compose NGINX Related Tutorials","title":"Table of contents"},{"location":"services/Media%20Management/bazarr/#folder-structure","text":"bazarr \u251c\u2500\u2500 config # Service data \u251c\u2500\u2500 docker-compose.yml # Service configuration \u2514\u2500\u2500 update_libseccomp_rpi4.sh # Script to install libseccomp on Raspberry Pi 4 Note: I do not remember why I needed to install libseccomp, but I kept the commands I've used in update_libseccomp_rpi4.sh file.","title":"Folder Structure"},{"location":"services/Media%20Management/bazarr/#docker-compose","text":"version: \"2.1\" services: bazarr: image: ghcr.io/linuxserver/bazarr container_name: bazarr environment: - PUID=1000 - PGID=1000 - TZ=${TZ} volumes: - ./config:/config - ${STORAGE_PATH}/Movies:/movies - ${STORAGE_PATH}/Series:/tv ports: - 6767:6767 restart: unless-stopped","title":"Docker-compose"},{"location":"services/Media%20Management/bazarr/#nginx","text":"","title":"NGINX"},{"location":"services/Media%20Management/bazarr/#http","text":"# Bazarr server { listen 80; server_name subtitles.EXAMPLE.COM; location / { proxy_pass http://bazarr:6767; } }","title":"HTTP"},{"location":"services/Media%20Management/bazarr/#https","text":"# Bazarr server { listen 80; server_name subtitles.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name subtitles.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://bazarr:6767; allow 192.168.77.0/24; deny all; } }","title":"HTTPS"},{"location":"services/Media%20Management/bazarr/#related-tutorials","text":"TODO: Configure Subtitle Profiles","title":"Related Tutorials"},{"location":"services/Media%20Management/deluge/","text":"Deluge is a lightweight, Free Software, cross-platform BitTorrent client. Table of contents Folder Structure Docker-compose NGINX Related Tutorials Folder Structure deluge \u251c\u2500\u2500 config # Service data \u2514\u2500\u2500 docker-compose.yml # Service configuration Docker-compose --- version: \"2.1\" services: deluge: image: ghcr.io/linuxserver/deluge container_name: deluge environment: - PUID=1000 - PGID=1000 - TZ=${TZ} - DELUGE_LOGLEVEL=info volumes: - \"./config:/config\" - ${STORAGE_PATH}/downloads:/downloads ports: - 58846:58846 - 8112:8112 restart: unless-stopped # .env STORAGE_PATH=/mnt/storage TZ=America/Sao_Paulo NGINX HTTP # Deluge server { listen 80; server_name torrent.EXAMPLE.COM; location / { proxy_pass http://deluge:8112; } } HTTPS # Deluge server { listen 80; server_name torrent.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name torrent.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://deluge:8112; } } Related Tutorials TODO: Login First time Configure Scheduling","title":"Deluge"},{"location":"services/Media%20Management/deluge/#table-of-contents","text":"Folder Structure Docker-compose NGINX Related Tutorials","title":"Table of contents"},{"location":"services/Media%20Management/deluge/#folder-structure","text":"deluge \u251c\u2500\u2500 config # Service data \u2514\u2500\u2500 docker-compose.yml # Service configuration","title":"Folder Structure"},{"location":"services/Media%20Management/deluge/#docker-compose","text":"--- version: \"2.1\" services: deluge: image: ghcr.io/linuxserver/deluge container_name: deluge environment: - PUID=1000 - PGID=1000 - TZ=${TZ} - DELUGE_LOGLEVEL=info volumes: - \"./config:/config\" - ${STORAGE_PATH}/downloads:/downloads ports: - 58846:58846 - 8112:8112 restart: unless-stopped # .env STORAGE_PATH=/mnt/storage TZ=America/Sao_Paulo","title":"Docker-compose"},{"location":"services/Media%20Management/deluge/#nginx","text":"","title":"NGINX"},{"location":"services/Media%20Management/deluge/#http","text":"# Deluge server { listen 80; server_name torrent.EXAMPLE.COM; location / { proxy_pass http://deluge:8112; } }","title":"HTTP"},{"location":"services/Media%20Management/deluge/#https","text":"# Deluge server { listen 80; server_name torrent.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name torrent.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://deluge:8112; } }","title":"HTTPS"},{"location":"services/Media%20Management/deluge/#related-tutorials","text":"TODO: Login First time Configure Scheduling","title":"Related Tutorials"},{"location":"services/Media%20Management/jackett/","text":"Jackett works as a proxy server: it translates queries from apps (Sonarr, SickRage, CouchPotato, Mylar, etc) into tracker-site-specific http queries, parses the html response, then sends results back to the requesting software. This allows for getting recent uploads (like RSS) and performing searches. Jackett is a single repository of maintained indexer scraping & translation logic - removing the burden from other apps. Table of contents Folder Structure Docker-compose NGINX Related Tutorials Folder Structure jackett \u251c\u2500\u2500 config # Service data \u2514\u2500\u2500 docker-compose.yml # Service configuration Docker-compose version: \"2.1\" services: jackett: image: ghcr.io/linuxserver/jackett container_name: jackett environment: - PUID=1000 - PGID=1000 - TZ=${TZ} - AUTO_UPDATE=true #optional - RUN_OPTS=<run options here> #optional volumes: - ./config:/config - ${STORAGE_PATH}/torrents:/downloads ports: - 9117:9117 restart: unless-stopped NGINX HTTP # Jackett server { listen 80; server_name tracker.EXAMPLE.COM; location / { proxy_pass http://jackett:9117; } } HTTPS # Jackett server { listen 80; server_name tracker.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name tracker.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://jackett:9117; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_redirect off; } } Related Tutorials TODO: Add trackers Integrate with Radarr/Sonarr","title":"Jackett"},{"location":"services/Media%20Management/jackett/#table-of-contents","text":"Folder Structure Docker-compose NGINX Related Tutorials","title":"Table of contents"},{"location":"services/Media%20Management/jackett/#folder-structure","text":"jackett \u251c\u2500\u2500 config # Service data \u2514\u2500\u2500 docker-compose.yml # Service configuration","title":"Folder Structure"},{"location":"services/Media%20Management/jackett/#docker-compose","text":"version: \"2.1\" services: jackett: image: ghcr.io/linuxserver/jackett container_name: jackett environment: - PUID=1000 - PGID=1000 - TZ=${TZ} - AUTO_UPDATE=true #optional - RUN_OPTS=<run options here> #optional volumes: - ./config:/config - ${STORAGE_PATH}/torrents:/downloads ports: - 9117:9117 restart: unless-stopped","title":"Docker-compose"},{"location":"services/Media%20Management/jackett/#nginx","text":"","title":"NGINX"},{"location":"services/Media%20Management/jackett/#http","text":"# Jackett server { listen 80; server_name tracker.EXAMPLE.COM; location / { proxy_pass http://jackett:9117; } }","title":"HTTP"},{"location":"services/Media%20Management/jackett/#https","text":"# Jackett server { listen 80; server_name tracker.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name tracker.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://jackett:9117; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_redirect off; } }","title":"HTTPS"},{"location":"services/Media%20Management/jackett/#related-tutorials","text":"TODO: Add trackers Integrate with Radarr/Sonarr","title":"Related Tutorials"},{"location":"services/Media%20Management/jellyfin/","text":"Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. Table of contents Folder Structure Docker-compose NGINX Related Tutorials Folder Structure jellyfin \u251c\u2500\u2500 cache/ # Server data \u251c\u2500\u2500 config/ # Cache \u251c\u2500\u2500 css/ # Styles \u2514\u2500\u2500 docker-compose.yml # Service configuration Docker-compose version: \"3.5\" services: jellyfin: image: jellyfin/jellyfin container_name: jellyfin volumes: - \"./config:/config\" - \"./cache:/cache\" - \"./css:/jellyfin/jellyfin-web/assets/css\" - ${STORAGE_PATH}:/media # STORAGE_PATH is defined at .env file shown below restart: \"unless-stopped\" environment: - JELLYFIN_PublishedServerUrl=https://play.EXAMPLE.COM # Change this to your URL - UID=1000 - GID=1000 ports: - 8096:8096 - 1900:1900 - 7359:7359 # .env STORAGE_PATH=/mnt/storage NGINX HTTP TODO: add HTTP config example HTTPS # Jellyfin # Uncomment the commented sections after you have acquired a SSL Certificate server { listen 80; listen [::]:80; server_name play.EXAMPLE.COM; # Uncomment to redirect HTTP to HTTPS return 301 https://$host$request_uri; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name play.EXAMPLE.COM; # use a variable to store the upstream proxy # in this example we are using a hostname which is resolved via DNS # (if you aren't using DNS remove the resolver line and change the variable to point to an IP address e.g `set $jellyfin 127.0.0.1`) set $jellyfin jellyfin; resolver 127.0.0.11 valid=30; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; #include /etc/letsencrypt/options-ssl-nginx.conf; #ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; add_header Strict-Transport-Security \"max-age=31536000\" always; ssl_trusted_certificate /etc/letsencrypt/live/EXAMPLE.COM/chain.pem; ssl_stapling on; ssl_stapling_verify on; # Security / XSS Mitigation Headers add_header X-Frame-Options \"SAMEORIGIN\"; add_header X-XSS-Protection \"1; mode=block\"; add_header X-Content-Type-Options \"nosniff\"; # Content Security Policy:x # See: https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP # Enforces https content and restricts JS/CSS to origin # External Javascript (such as cast_sender.js for Chromecast) must be whitelisted. #add_header Content-Security-Policy \"default-src https: data: blob: http://image.tmdb.org; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline' https://www.gstatic.com/cv/js/sender/v1/cast_sender.js https://www.youtube.com blob:; worker-src 'self' blob:; connect-src 'self'; object-src 'none'; frame-ancestors 'self'\"; add_header Content-Security-Policy \"default-src https: data: blob:; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/accentlist.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/base.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/bottombarprogress.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/fixes.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/jf_font.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/overlayprogress.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/rounding.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/rounding_circlehover.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/smallercast.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/rounding_circlehover.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/cornerindicator/indicator_floating.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/cornerindicator/indicator_corner.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/effects/glassy.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/effects/pan-animation.css https://ctalvio.github.io/Monochromic/backdrop-hack_style.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/effects/hoverglow.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/effects/scrollfade.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/episodelist/episodes_compactlist.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/episodelist/episodes_grid.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/fields/fields_border.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/fields/fields_noborder.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/header/header_transparent.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/header/header_transparent-dashboard.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/login/login_frame.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/login/login_minimalistic.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/login/login_frame.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/presets/monochromic_preset.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/presets/kaleidochromic_preset.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/presets/novachromic_preset.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/titlepage/title_banner.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/titlepage/title_banner_logo.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/titlepage/title_simple.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/titlepage/title_simple-logo.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/type/light.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/type/dark.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/type/colorful.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/type/dark_withaccent.css https://fonts.googleapis.com/css2; script-src 'self' 'unsafe-inline' https://www.gstatic.com/cv/js/sender/v1/cast_sender.js worker-src 'self' blob:; connect-src 'self'; object-src 'none'; frame-ancestors 'self'\"; location = / { return 302 http://$host/web/; } location / { # Proxy main Jellyfin traffic proxy_pass http://$jellyfin:8096; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Protocol $scheme; proxy_set_header X-Forwarded-Host $http_host; # Disable buffering when the nginx proxy gets very resource heavy upon streaming proxy_buffering off; } # location block for /web - This is purely for aesthetics so /web/#!/ works instead of having to go to /web/index.html/#!/ location = /web/ { # Proxy main Jellyfin traffic proxy_pass http://$jellyfin:8096/web/index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Protocol $scheme; proxy_set_header X-Forwarded-Host $http_host; } location /socket { # Proxy Jellyfin Websockets traffic proxy_pass http://$jellyfin:8096; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Protocol $scheme; proxy_set_header X-Forwarded-Host $http_host; } } Related Tutorials TODO: Tutorial on how to change CSS styling","title":"Jellyfin"},{"location":"services/Media%20Management/jellyfin/#table-of-contents","text":"Folder Structure Docker-compose NGINX Related Tutorials","title":"Table of contents"},{"location":"services/Media%20Management/jellyfin/#folder-structure","text":"jellyfin \u251c\u2500\u2500 cache/ # Server data \u251c\u2500\u2500 config/ # Cache \u251c\u2500\u2500 css/ # Styles \u2514\u2500\u2500 docker-compose.yml # Service configuration","title":"Folder Structure"},{"location":"services/Media%20Management/jellyfin/#docker-compose","text":"version: \"3.5\" services: jellyfin: image: jellyfin/jellyfin container_name: jellyfin volumes: - \"./config:/config\" - \"./cache:/cache\" - \"./css:/jellyfin/jellyfin-web/assets/css\" - ${STORAGE_PATH}:/media # STORAGE_PATH is defined at .env file shown below restart: \"unless-stopped\" environment: - JELLYFIN_PublishedServerUrl=https://play.EXAMPLE.COM # Change this to your URL - UID=1000 - GID=1000 ports: - 8096:8096 - 1900:1900 - 7359:7359 # .env STORAGE_PATH=/mnt/storage","title":"Docker-compose"},{"location":"services/Media%20Management/jellyfin/#nginx","text":"","title":"NGINX"},{"location":"services/Media%20Management/jellyfin/#http","text":"TODO: add HTTP config example","title":"HTTP"},{"location":"services/Media%20Management/jellyfin/#https","text":"# Jellyfin # Uncomment the commented sections after you have acquired a SSL Certificate server { listen 80; listen [::]:80; server_name play.EXAMPLE.COM; # Uncomment to redirect HTTP to HTTPS return 301 https://$host$request_uri; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name play.EXAMPLE.COM; # use a variable to store the upstream proxy # in this example we are using a hostname which is resolved via DNS # (if you aren't using DNS remove the resolver line and change the variable to point to an IP address e.g `set $jellyfin 127.0.0.1`) set $jellyfin jellyfin; resolver 127.0.0.11 valid=30; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; #include /etc/letsencrypt/options-ssl-nginx.conf; #ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; add_header Strict-Transport-Security \"max-age=31536000\" always; ssl_trusted_certificate /etc/letsencrypt/live/EXAMPLE.COM/chain.pem; ssl_stapling on; ssl_stapling_verify on; # Security / XSS Mitigation Headers add_header X-Frame-Options \"SAMEORIGIN\"; add_header X-XSS-Protection \"1; mode=block\"; add_header X-Content-Type-Options \"nosniff\"; # Content Security Policy:x # See: https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP # Enforces https content and restricts JS/CSS to origin # External Javascript (such as cast_sender.js for Chromecast) must be whitelisted. #add_header Content-Security-Policy \"default-src https: data: blob: http://image.tmdb.org; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline' https://www.gstatic.com/cv/js/sender/v1/cast_sender.js https://www.youtube.com blob:; worker-src 'self' blob:; connect-src 'self'; object-src 'none'; frame-ancestors 'self'\"; add_header Content-Security-Policy \"default-src https: data: blob:; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/accentlist.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/base.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/bottombarprogress.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/fixes.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/jf_font.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/overlayprogress.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/rounding.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/rounding_circlehover.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/smallercast.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/rounding_circlehover.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/cornerindicator/indicator_floating.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/cornerindicator/indicator_corner.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/effects/glassy.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/effects/pan-animation.css https://ctalvio.github.io/Monochromic/backdrop-hack_style.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/effects/hoverglow.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/effects/scrollfade.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/episodelist/episodes_compactlist.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/episodelist/episodes_grid.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/fields/fields_border.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/fields/fields_noborder.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/header/header_transparent.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/header/header_transparent-dashboard.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/login/login_frame.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/login/login_minimalistic.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/login/login_frame.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/presets/monochromic_preset.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/presets/kaleidochromic_preset.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/presets/novachromic_preset.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/titlepage/title_banner.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/titlepage/title_banner_logo.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/titlepage/title_simple.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/titlepage/title_simple-logo.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/type/light.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/type/dark.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/type/colorful.css https://cdn.jsdelivr.net/gh/CTalvio/Ultrachromic/type/dark_withaccent.css https://fonts.googleapis.com/css2; script-src 'self' 'unsafe-inline' https://www.gstatic.com/cv/js/sender/v1/cast_sender.js worker-src 'self' blob:; connect-src 'self'; object-src 'none'; frame-ancestors 'self'\"; location = / { return 302 http://$host/web/; } location / { # Proxy main Jellyfin traffic proxy_pass http://$jellyfin:8096; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Protocol $scheme; proxy_set_header X-Forwarded-Host $http_host; # Disable buffering when the nginx proxy gets very resource heavy upon streaming proxy_buffering off; } # location block for /web - This is purely for aesthetics so /web/#!/ works instead of having to go to /web/index.html/#!/ location = /web/ { # Proxy main Jellyfin traffic proxy_pass http://$jellyfin:8096/web/index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Protocol $scheme; proxy_set_header X-Forwarded-Host $http_host; } location /socket { # Proxy Jellyfin Websockets traffic proxy_pass http://$jellyfin:8096; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Protocol $scheme; proxy_set_header X-Forwarded-Host $http_host; } }","title":"HTTPS"},{"location":"services/Media%20Management/jellyfin/#related-tutorials","text":"TODO: Tutorial on how to change CSS styling","title":"Related Tutorials"},{"location":"services/Media%20Management/ombi/","text":"Ombi allows you to host your own Plex Request and user management system. If you are sharing your Plex server with other users, allow them to request new content using an easy to manage interface! Manage all your requests for Movies and TV with ease, leave notes for the user and get notification when a user requests something. Allow your users to post issues against their requests so you know there is a problem with the audio etc. Even automatically send them weekly newsletters of new content that has been added to your Plex server! Table of contents Folder Structure Docker-compose NGINX Folder Structure ombi \u251c\u2500\u2500 config \u2514\u2500\u2500 docker-compose.yml Docker-compose --- version: \"2.1\" services: ombi: image: lscr.io/linuxserver/ombi:latest container_name: ombi environment: - PUID=1000 - PGID=1000 - TZ=America/Sao_Paulo volumes: - ./config:/config ports: - 3579:3579 restart: unless-stopped NGINX HTTP # Ombi v4 Subdomain # Replace EXAMPLE.COM with your domain server { listen 80; server_name requests.EXAMPLE.COM; resolver 1.1.1.1 1.0.0.1 valid=300s; resolver_timeout 10s; gzip on; gzip_vary on; gzip_min_length 1000; gzip_proxied any; gzip_types text/plain text/css text/xml application/xml text/javascript application/x-javascript image/svg+xml; gzip_disable \"MSIE [1-6]\\.\"; location / { proxy_pass http://ombi:3579; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } # This allows access to the actual api location /api { proxy_pass http://ombi:3579; } # This allows access to the documentation for the api location /swagger { proxy_pass http://ombi:3579; } } HTTPS # Ombi v4 Subdomain # Replace EXAMPLE.COM with your domain server { listen 80; server_name requests.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name requests.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA'; ssl_session_tickets off; ssl_ecdh_curve secp384r1; resolver 1.1.1.1 1.0.0.1 valid=300s; resolver_timeout 10s; gzip on; gzip_vary on; gzip_min_length 1000; gzip_proxied any; gzip_types text/plain text/css text/xml application/xml text/javascript application/x-javascript image/svg+xml; gzip_disable \"MSIE [1-6]\\.\"; location / { proxy_pass http://ombi:3579; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } # This allows access to the actual api location /api { proxy_pass http://ombi:3579; } # This allows access to the documentation for the api location /swagger { proxy_pass http://ombi:3579; } } Customization","title":"Ombi"},{"location":"services/Media%20Management/ombi/#table-of-contents","text":"Folder Structure Docker-compose NGINX","title":"Table of contents"},{"location":"services/Media%20Management/ombi/#folder-structure","text":"ombi \u251c\u2500\u2500 config \u2514\u2500\u2500 docker-compose.yml","title":"Folder Structure"},{"location":"services/Media%20Management/ombi/#docker-compose","text":"--- version: \"2.1\" services: ombi: image: lscr.io/linuxserver/ombi:latest container_name: ombi environment: - PUID=1000 - PGID=1000 - TZ=America/Sao_Paulo volumes: - ./config:/config ports: - 3579:3579 restart: unless-stopped","title":"Docker-compose"},{"location":"services/Media%20Management/ombi/#nginx","text":"","title":"NGINX"},{"location":"services/Media%20Management/ombi/#http","text":"# Ombi v4 Subdomain # Replace EXAMPLE.COM with your domain server { listen 80; server_name requests.EXAMPLE.COM; resolver 1.1.1.1 1.0.0.1 valid=300s; resolver_timeout 10s; gzip on; gzip_vary on; gzip_min_length 1000; gzip_proxied any; gzip_types text/plain text/css text/xml application/xml text/javascript application/x-javascript image/svg+xml; gzip_disable \"MSIE [1-6]\\.\"; location / { proxy_pass http://ombi:3579; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } # This allows access to the actual api location /api { proxy_pass http://ombi:3579; } # This allows access to the documentation for the api location /swagger { proxy_pass http://ombi:3579; } }","title":"HTTP"},{"location":"services/Media%20Management/ombi/#https","text":"# Ombi v4 Subdomain # Replace EXAMPLE.COM with your domain server { listen 80; server_name requests.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name requests.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA'; ssl_session_tickets off; ssl_ecdh_curve secp384r1; resolver 1.1.1.1 1.0.0.1 valid=300s; resolver_timeout 10s; gzip on; gzip_vary on; gzip_min_length 1000; gzip_proxied any; gzip_types text/plain text/css text/xml application/xml text/javascript application/x-javascript image/svg+xml; gzip_disable \"MSIE [1-6]\\.\"; location / { proxy_pass http://ombi:3579; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } # This allows access to the actual api location /api { proxy_pass http://ombi:3579; } # This allows access to the documentation for the api location /swagger { proxy_pass http://ombi:3579; } }","title":"HTTPS"},{"location":"services/Media%20Management/ombi/#customization","text":"","title":"Customization"},{"location":"services/Media%20Management/radarr/","text":"Radarr - A fork of Sonarr to work with movies \u00e0 la Couchpotato. Table of contents Folder Structure Docker-compose NGINX Related Tutorials Folder Structure radarr \u251c\u2500\u2500 config \u2514\u2500\u2500 docker-compose.yml Docker-compose version: \"2.1\" services: radarr: image: ghcr.io/linuxserver/radarr container_name: radarr environment: - PUID=1000 - PGID=1000 - TZ=${TZ} volumes: - ./config:/config - ${STORAGE_PATH}/Movies:/movies - ${STORAGE_PATH}/downloads:/downloads ports: - 7878:7878 restart: unless-stopped NGINX HTTP # Radarr server { listen 80; server_name movies.EXAMPLE.COM; location / { proxy_pass http://radarr:7878; } } HTTPS # Radarr server { listen 80; server_name movies.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name movies.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://radarr:7878; } } Related Tutorials TODO: Create profile Connect to Deluge Telegram Notification","title":"Radarr"},{"location":"services/Media%20Management/radarr/#table-of-contents","text":"Folder Structure Docker-compose NGINX Related Tutorials","title":"Table of contents"},{"location":"services/Media%20Management/radarr/#folder-structure","text":"radarr \u251c\u2500\u2500 config \u2514\u2500\u2500 docker-compose.yml","title":"Folder Structure"},{"location":"services/Media%20Management/radarr/#docker-compose","text":"version: \"2.1\" services: radarr: image: ghcr.io/linuxserver/radarr container_name: radarr environment: - PUID=1000 - PGID=1000 - TZ=${TZ} volumes: - ./config:/config - ${STORAGE_PATH}/Movies:/movies - ${STORAGE_PATH}/downloads:/downloads ports: - 7878:7878 restart: unless-stopped","title":"Docker-compose"},{"location":"services/Media%20Management/radarr/#nginx","text":"","title":"NGINX"},{"location":"services/Media%20Management/radarr/#http","text":"# Radarr server { listen 80; server_name movies.EXAMPLE.COM; location / { proxy_pass http://radarr:7878; } }","title":"HTTP"},{"location":"services/Media%20Management/radarr/#https","text":"# Radarr server { listen 80; server_name movies.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name movies.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://radarr:7878; } }","title":"HTTPS"},{"location":"services/Media%20Management/radarr/#related-tutorials","text":"TODO: Create profile Connect to Deluge Telegram Notification","title":"Related Tutorials"},{"location":"services/Media%20Management/sonarr/","text":"Sonarr (formerly NZBdrone) is a PVR for usenet and bittorrent users. It can monitor multiple RSS feeds for new episodes of your favorite shows and will grab, sort and rename them. It can also be configured to automatically upgrade the quality of files already downloaded when a better quality format becomes available. Table of contents Folder Structure Docker-compose NGINX Related Tutorials Folder Structure sonarr \u251c\u2500\u2500 config \u2514\u2500\u2500 docker-compose.yml Docker-compose version: \"2.1\" services: sonarr: image: ghcr.io/linuxserver/sonarr container_name: sonarr environment: - PUID=1000 - PGID=1000 - TZ=${TZ} volumes: - ./config:/config - ${STORAGE_PATH}/Series:/tv - ${STORAGE_PATH}/downloads:/downloads ports: - 8989:8989 restart: unless-stopped NGINX HTTP # Sonarr server { listen 80; server_name series.EXAMPLE.COM; location / { proxy_pass http://sonarr:8989; } } HTTPS # Sonarr server { listen 80; server_name series.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name series.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/vcosta.dev/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/vcosta.dev/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://sonarr:8989; } } Related Tutorials TODO: - Connect to Deluge - Connect to Jackett - Connect to Jellyfin","title":"Sonarr"},{"location":"services/Media%20Management/sonarr/#table-of-contents","text":"Folder Structure Docker-compose NGINX Related Tutorials","title":"Table of contents"},{"location":"services/Media%20Management/sonarr/#folder-structure","text":"sonarr \u251c\u2500\u2500 config \u2514\u2500\u2500 docker-compose.yml","title":"Folder Structure"},{"location":"services/Media%20Management/sonarr/#docker-compose","text":"version: \"2.1\" services: sonarr: image: ghcr.io/linuxserver/sonarr container_name: sonarr environment: - PUID=1000 - PGID=1000 - TZ=${TZ} volumes: - ./config:/config - ${STORAGE_PATH}/Series:/tv - ${STORAGE_PATH}/downloads:/downloads ports: - 8989:8989 restart: unless-stopped","title":"Docker-compose"},{"location":"services/Media%20Management/sonarr/#nginx","text":"","title":"NGINX"},{"location":"services/Media%20Management/sonarr/#http","text":"# Sonarr server { listen 80; server_name series.EXAMPLE.COM; location / { proxy_pass http://sonarr:8989; } }","title":"HTTP"},{"location":"services/Media%20Management/sonarr/#https","text":"# Sonarr server { listen 80; server_name series.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name series.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/vcosta.dev/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/vcosta.dev/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://sonarr:8989; } }","title":"HTTPS"},{"location":"services/Media%20Management/sonarr/#related-tutorials","text":"TODO: - Connect to Deluge - Connect to Jackett - Connect to Jellyfin","title":"Related Tutorials"},{"location":"services/Network/nginx/","text":"Nginx , stylized as NGI\u0418X, is a web server that can also be used as a reverse proxy, load balancer, mail proxy and HTTP cache. Table of contents Folder Structure Docker-compose Integration Related Tutorials Folder Structure nginx \u251c\u2500\u2500 docker-compose.yml # Service configuration \u251c\u2500\u2500 nginx.conf # NGINX configuration \u251c\u2500\u2500 README.md \u2514\u2500\u2500 template # Template and Script to manage nginx.conf dynamically - WORK IN PROGRESS \u251c\u2500\u2500 nginx.conf.j2 \u2514\u2500\u2500 template.py Docker-compose version: \"3\" services: nginx: image: nginx container_name: nginx ports: - \"80:80\" - \"443:443\" volumes: - ./nginx.conf:/etc/nginx/nginx.conf - ../Certbot-Godaddy/config:/etc/letsencrypt # Only needed for HTTPS configuration restart: unless-stopped # This network configuration must be added to all services behind NGINX # NGIX must be on the same network of the services it will be routing requests networks: default: external: name: apps Integration TODO: Network diagram Related Tutorials TODO: Tutorial adding a service do nginx.conf deny external access How to use nginx templating","title":"Nginx"},{"location":"services/Network/nginx/#table-of-contents","text":"Folder Structure Docker-compose Integration Related Tutorials","title":"Table of contents"},{"location":"services/Network/nginx/#folder-structure","text":"nginx \u251c\u2500\u2500 docker-compose.yml # Service configuration \u251c\u2500\u2500 nginx.conf # NGINX configuration \u251c\u2500\u2500 README.md \u2514\u2500\u2500 template # Template and Script to manage nginx.conf dynamically - WORK IN PROGRESS \u251c\u2500\u2500 nginx.conf.j2 \u2514\u2500\u2500 template.py","title":"Folder Structure"},{"location":"services/Network/nginx/#docker-compose","text":"version: \"3\" services: nginx: image: nginx container_name: nginx ports: - \"80:80\" - \"443:443\" volumes: - ./nginx.conf:/etc/nginx/nginx.conf - ../Certbot-Godaddy/config:/etc/letsencrypt # Only needed for HTTPS configuration restart: unless-stopped # This network configuration must be added to all services behind NGINX # NGIX must be on the same network of the services it will be routing requests networks: default: external: name: apps","title":"Docker-compose"},{"location":"services/Network/nginx/#integration","text":"TODO: Network diagram","title":"Integration"},{"location":"services/Network/nginx/#related-tutorials","text":"TODO: Tutorial adding a service do nginx.conf deny external access How to use nginx templating","title":"Related Tutorials"},{"location":"services/Network/pihole/","text":"Table of contents Folder Structure Docker-compose Integration NGINX Related Tutorials Folder Structure pihole \u251c\u2500\u2500 docker-compose.yml # Service configuration \u251c\u2500\u2500 etc-dnsmasq.d \u2514\u2500\u2500 etc-pihole # Block lists (managed by application) Docker-compose version: \"3\" # More info at https://github.com/pi-hole/docker-pi-hole/ and https://docs.pi-hole.net/ services: pihole: container_name: pihole image: pihole/pihole:latest ports: - \"53:53/tcp\" - \"53:53/udp\" - \"67:67/udp\" - \"8010:80/tcp\" - \"8443:443/tcp\" environment: ServerIP: ${SERVER_IP} VIRTUAL_HOST: ${CUSTOM_DOMAIN} TZ: ${TZ} WEBPASSWORD: ${PASSWORD} volumes: - \"./etc-pihole/:/etc/pihole/\" - \"./etc-dnsmasq.d/:/etc/dnsmasq.d/\" # Recommended but not required (DHCP needs NET_ADMIN) # https://github.com/pi-hole/docker-pi-hole#note-on-capabilities cap_add: - NET_ADMIN restart: unless-stopped # .env SERVER_IP=192.168.0.104 CUSTOM_DOMAIN=hole.EXAMPLE.COM TZ=America/Sao_Paulo PASSWORD='password' Integration TODO: Network diagram NGINX HTTP # PiHole server { listen 80; server_name hole.EXAMPLE.COM; location / { proxy_pass http://pihole/admin/; } } HTTPS # PiHole server { listen 80; server_name hole.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name hole.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://pihole/admin/; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; } } Related Tutorials TODO: Use PiHole as internal DNS Add block lists","title":"Pihole"},{"location":"services/Network/pihole/#table-of-contents","text":"Folder Structure Docker-compose Integration NGINX Related Tutorials","title":"Table of contents"},{"location":"services/Network/pihole/#folder-structure","text":"pihole \u251c\u2500\u2500 docker-compose.yml # Service configuration \u251c\u2500\u2500 etc-dnsmasq.d \u2514\u2500\u2500 etc-pihole # Block lists (managed by application)","title":"Folder Structure"},{"location":"services/Network/pihole/#docker-compose","text":"version: \"3\" # More info at https://github.com/pi-hole/docker-pi-hole/ and https://docs.pi-hole.net/ services: pihole: container_name: pihole image: pihole/pihole:latest ports: - \"53:53/tcp\" - \"53:53/udp\" - \"67:67/udp\" - \"8010:80/tcp\" - \"8443:443/tcp\" environment: ServerIP: ${SERVER_IP} VIRTUAL_HOST: ${CUSTOM_DOMAIN} TZ: ${TZ} WEBPASSWORD: ${PASSWORD} volumes: - \"./etc-pihole/:/etc/pihole/\" - \"./etc-dnsmasq.d/:/etc/dnsmasq.d/\" # Recommended but not required (DHCP needs NET_ADMIN) # https://github.com/pi-hole/docker-pi-hole#note-on-capabilities cap_add: - NET_ADMIN restart: unless-stopped # .env SERVER_IP=192.168.0.104 CUSTOM_DOMAIN=hole.EXAMPLE.COM TZ=America/Sao_Paulo PASSWORD='password'","title":"Docker-compose"},{"location":"services/Network/pihole/#integration","text":"TODO: Network diagram","title":"Integration"},{"location":"services/Network/pihole/#nginx","text":"","title":"NGINX"},{"location":"services/Network/pihole/#http","text":"# PiHole server { listen 80; server_name hole.EXAMPLE.COM; location / { proxy_pass http://pihole/admin/; } }","title":"HTTP"},{"location":"services/Network/pihole/#https","text":"# PiHole server { listen 80; server_name hole.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name hole.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://pihole/admin/; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; } }","title":"HTTPS"},{"location":"services/Network/pihole/#related-tutorials","text":"TODO: Use PiHole as internal DNS Add block lists","title":"Related Tutorials"},{"location":"services/Other/flame/","text":"Flame is a self-hosted startpage for your server. Its design is inspired (heavily) by SUI. Flame is very easy to setup and use. With built-in editors, it allows you to setup your very own application hub in no time - no file editing necessary. Table of contents Folder Structure Docker-compose NGINX Related Tutorials Folder Structure flame \u251c\u2500\u2500 data \u2514\u2500\u2500 docker-compose.yml Docker-compose version: \"2.1\" services: flame: image: pawelmalak/flame:multiarch container_name: flame volumes: - ./data:/app/data ports: - 5005:5005 restart: unless-stopped NGINX HTTP # Flame server { listen 80 default_server; server_name home.EXAMPLE.COM home; location / { proxy_pass http://flame:5005; } } HTTPS # Flame server { listen 80 default_server; server_name home.EXAMPLE.COM home; return 301 https://$server_name$request_uri; } map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { listen 443 ssl; server_name home.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; if ($host != $server_name) { return 301 https://home.EXAMPLE.COM$request_uri; } location /socket { proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_http_version 1.1; proxy_pass http://flame:5005/socket; } location / { proxy_pass http://flame:5005; } } Related Tutorials TODO: Add applications on homepage Configure Weather","title":"Flame"},{"location":"services/Other/flame/#table-of-contents","text":"Folder Structure Docker-compose NGINX Related Tutorials","title":"Table of contents"},{"location":"services/Other/flame/#folder-structure","text":"flame \u251c\u2500\u2500 data \u2514\u2500\u2500 docker-compose.yml","title":"Folder Structure"},{"location":"services/Other/flame/#docker-compose","text":"version: \"2.1\" services: flame: image: pawelmalak/flame:multiarch container_name: flame volumes: - ./data:/app/data ports: - 5005:5005 restart: unless-stopped","title":"Docker-compose"},{"location":"services/Other/flame/#nginx","text":"","title":"NGINX"},{"location":"services/Other/flame/#http","text":"# Flame server { listen 80 default_server; server_name home.EXAMPLE.COM home; location / { proxy_pass http://flame:5005; } }","title":"HTTP"},{"location":"services/Other/flame/#https","text":"# Flame server { listen 80 default_server; server_name home.EXAMPLE.COM home; return 301 https://$server_name$request_uri; } map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { listen 443 ssl; server_name home.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; if ($host != $server_name) { return 301 https://home.EXAMPLE.COM$request_uri; } location /socket { proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_http_version 1.1; proxy_pass http://flame:5005/socket; } location / { proxy_pass http://flame:5005; } }","title":"HTTPS"},{"location":"services/Other/flame/#related-tutorials","text":"TODO: Add applications on homepage Configure Weather","title":"Related Tutorials"},{"location":"services/Other/planka/","text":"Planka is a Trello-like kanban board built with React and Redux. Table of contents Folder Structure Docker-compose NGINX Related Tutorials Folder Structure planka \u251c\u2500\u2500 attachments \u251c\u2500\u2500 db-data \u251c\u2500\u2500 docker-compose.yml \u251c\u2500\u2500 project-background-images \u2514\u2500\u2500 user-avatars \u2514\u2500\u2500 54f7e083-9836-4fea-90cf-ed6b809ef016 Docker-compose version: \"3\" services: planka: image: meltyshev/planka:latest container_name: planka command: > bash -c \"for i in `seq 1 30`; do ./start.sh && s=$$? && break || s=$$?; echo \\\"Tried $$i times. Waiting 5 seconds...\\\"; sleep 5; done; (exit $$s)\" restart: unless-stopped volumes: # These folders are mapped only to persist your data # you dont need to change anything in here - ./user-avatars:/app/public/user-avatars - ./project-background-images:/app/public/project-background-images - ./attachments:/app/public/attachments ports: - 1337:1337 environment: - BASE_URL=https://tasks.EXAMPLE.COM # Change this to the URL you will use for this service - DATABASE_URL=postgresql://postgres@postgres/planka - SECRET_KEY=notsecretkey - TRUST_PROXY=1 depends_on: - postgres postgres: image: postgres:alpine container_name: planka_db restart: unless-stopped volumes: # This folder is mapped only to persist your data # you dont need to change anything in here - ./db-data:/var/lib/postgresql/data environment: - POSTGRES_DB=planka - POSTGRES_HOST_AUTH_METHOD=trust NGINX HTTP # Planka server { listen 80; server_name tasks.EXAMPLE.COM tasks; location / { proxy_pass http://planka:1337; } } HTTPS # Planka server { listen 80; server_name tasks.EXAMPLE.COM tasks; return 301 https://$server_name$request_uri; } map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { listen 443 ssl; server_name tasks.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; if ($host != $server_name) { return 301 https://tasks.EXAMPLE.COM$request_uri; } location /socket.io { proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_http_version 1.1; proxy_pass http://planka:1337/socket.io; } location / { proxy_pass http://planka:1337; allow 192.168.77.0/24; deny all; } } Related Tutorial TODO: Basic board creation","title":"Planka"},{"location":"services/Other/planka/#table-of-contents","text":"Folder Structure Docker-compose NGINX Related Tutorials","title":"Table of contents"},{"location":"services/Other/planka/#folder-structure","text":"planka \u251c\u2500\u2500 attachments \u251c\u2500\u2500 db-data \u251c\u2500\u2500 docker-compose.yml \u251c\u2500\u2500 project-background-images \u2514\u2500\u2500 user-avatars \u2514\u2500\u2500 54f7e083-9836-4fea-90cf-ed6b809ef016","title":"Folder Structure"},{"location":"services/Other/planka/#docker-compose","text":"version: \"3\" services: planka: image: meltyshev/planka:latest container_name: planka command: > bash -c \"for i in `seq 1 30`; do ./start.sh && s=$$? && break || s=$$?; echo \\\"Tried $$i times. Waiting 5 seconds...\\\"; sleep 5; done; (exit $$s)\" restart: unless-stopped volumes: # These folders are mapped only to persist your data # you dont need to change anything in here - ./user-avatars:/app/public/user-avatars - ./project-background-images:/app/public/project-background-images - ./attachments:/app/public/attachments ports: - 1337:1337 environment: - BASE_URL=https://tasks.EXAMPLE.COM # Change this to the URL you will use for this service - DATABASE_URL=postgresql://postgres@postgres/planka - SECRET_KEY=notsecretkey - TRUST_PROXY=1 depends_on: - postgres postgres: image: postgres:alpine container_name: planka_db restart: unless-stopped volumes: # This folder is mapped only to persist your data # you dont need to change anything in here - ./db-data:/var/lib/postgresql/data environment: - POSTGRES_DB=planka - POSTGRES_HOST_AUTH_METHOD=trust","title":"Docker-compose"},{"location":"services/Other/planka/#nginx","text":"","title":"NGINX"},{"location":"services/Other/planka/#http","text":"# Planka server { listen 80; server_name tasks.EXAMPLE.COM tasks; location / { proxy_pass http://planka:1337; } }","title":"HTTP"},{"location":"services/Other/planka/#https","text":"# Planka server { listen 80; server_name tasks.EXAMPLE.COM tasks; return 301 https://$server_name$request_uri; } map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { listen 443 ssl; server_name tasks.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; if ($host != $server_name) { return 301 https://tasks.EXAMPLE.COM$request_uri; } location /socket.io { proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_http_version 1.1; proxy_pass http://planka:1337/socket.io; } location / { proxy_pass http://planka:1337; allow 192.168.77.0/24; deny all; } }","title":"HTTPS"},{"location":"services/Other/planka/#related-tutorial","text":"TODO: Basic board creation","title":"Related Tutorial"},{"location":"services/Other/portainer/","text":"Portainer is a self-service container service delivery platform. It is the definitive container management GUI for Kubernetes, Docker and Swarm. Table of contents Folder Structure Docker-compose NGINX Folder Structure portainer \u251c\u2500\u2500 data # Service data \u2514\u2500\u2500 docker-compose.yml # Service configuration Docker-compose version: \"2\" services: portainer: image: portainer/portainer-ce command: -H unix:///var/run/docker.sock container_name: portainer restart: unless-stopped ports: - 9000:9000 # - 8000:8000 volumes: - /var/run/docker.sock:/var/run/docker.sock # Portainer needs to connect to your host docker.sock - ./data:/data NGINX HTTP # Portainer server { listen 80; server_name admin.EXAMPLE.COM; location / { proxy_pass http://portainer:9000; } } HTTPS # Portainer server { listen 80; server_name admin.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name admin.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://portainer:9000; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } }","title":"Portainer"},{"location":"services/Other/portainer/#table-of-contents","text":"Folder Structure Docker-compose NGINX","title":"Table of contents"},{"location":"services/Other/portainer/#folder-structure","text":"portainer \u251c\u2500\u2500 data # Service data \u2514\u2500\u2500 docker-compose.yml # Service configuration","title":"Folder Structure"},{"location":"services/Other/portainer/#docker-compose","text":"version: \"2\" services: portainer: image: portainer/portainer-ce command: -H unix:///var/run/docker.sock container_name: portainer restart: unless-stopped ports: - 9000:9000 # - 8000:8000 volumes: - /var/run/docker.sock:/var/run/docker.sock # Portainer needs to connect to your host docker.sock - ./data:/data","title":"Docker-compose"},{"location":"services/Other/portainer/#nginx","text":"","title":"NGINX"},{"location":"services/Other/portainer/#http","text":"# Portainer server { listen 80; server_name admin.EXAMPLE.COM; location / { proxy_pass http://portainer:9000; } }","title":"HTTP"},{"location":"services/Other/portainer/#https","text":"# Portainer server { listen 80; server_name admin.EXAMPLE.COM; return 301 https://$server_name$request_uri; } server { listen 443 ssl http2; server_name admin.EXAMPLE.COM; ssl_certificate /etc/letsencrypt/live/EXAMPLE.COM/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/EXAMPLE.COM/privkey.pem; ssl_session_cache builtin:1000; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / { proxy_pass http://portainer:9000; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } }","title":"HTTPS"}]}